#!/usr/bin/env ruby

# requires are splitted in two for efficiency reasons
# ditz should be really fast when using it for
# completion.
require 'operator'

op = Ditz::Operator.new

# a secret option for shell completion
if ARGV.include? '--commands'
  puts op.class.operations.map { |name, _| name }
  exit 0
end

require 'rubygems'
require 'fileutils'
require 'trollop'; include Trollop
require "ditz"

PROJECT_FN = "project.yaml"
CONFIG_FN = ".ditz-config"
def ISSUE_TO_FN i; "issue-#{i.id}.yaml" end

$opts = options do
  version "ditz #{Ditz::VERSION}"
  opt :issue_dir, "Issue database dir", :default => "bugs"
  opt :config_file, "Configuration file", :default => File.join(ENV["HOME"], CONFIG_FN)
  opt :verbose, "Verbose output", :default => false
end

cmd = ARGV.shift or die "expecting a ditz command"
dir = $opts[:issue_dir]

case cmd # some special cases not handled by Ditz::Operator
when "init"
  die "#{dir} directory already exists" if File.exists? dir
  FileUtils.mkdir dir
  fn = File.join dir, PROJECT_FN
  project = op.init
  project.save! fn
  puts "Ok, #{dir} directory created successfully."
  exit
when "help"
  op.do "help", nil, nil, ARGV
  exit
end

project_root = Ditz::find_project_root dir, Dir.pwd

die "No #{dir} directory---use 'ditz init' to initialize" unless project_root != nil and File.exists? project_root


project = begin
  fn = File.join project_root, PROJECT_FN
  Ditz::debug "loading project from #{fn}"
  project = Ditz::Project.from fn

  fn = File.join project_root, "issue-*.yaml"
  Ditz::debug "loading issues from #{fn}"
  project.issues = Dir[fn].map { |fn| Ditz::Issue.from fn }
  Ditz::debug "found #{project.issues.size} issues"
  project
rescue SystemCallError, Ditz::Project::Error => e
  die "#{e.message} (use 'init' to initialize)"
end

project.validate!
project.assign_issue_names!
project.each_modelobject { |o| o.after_deserialize project }

config = begin
  if File.exists? CONFIG_FN
    Ditz::debug "loading local config from #{CONFIG_FN}"
    Ditz::Config.from CONFIG_FN
  else
    Ditz::debug "loading global config from #{$opts[:config_file]}"
    Ditz::Config.from $opts[:config_file]
  end
rescue SystemCallError, Ditz::ModelObject::ModelError => e
  puts <<EOS
I wasn't able to find a configuration file #{$opts[:config_file]}.
We'll set it up right now.
EOS
  Ditz::Config.create_interactively
end

unless op.has_operation? cmd
  die "no such command: #{cmd}"
end

## talk about the law of unintended consequences. 'gets' requires this.
args = []
args << ARGV.shift until ARGV.empty?

Ditz::debug "executing command #{cmd}"
begin
  op.do cmd, project, config, args
rescue Ditz::Operator::Error => e
  die e.message
rescue Interrupt
  exit 1
end

## save project.yaml
dirty = project.each_modelobject { |o| break true if o.changed? } || false
if dirty
  fn = File.join project_root, PROJECT_FN
  Ditz::debug "project is dirty, saving #{fn}"
  project.each_modelobject { |o| o.before_serialize project }
  project.save! fn
end

## project issues are not model fields proper, so they must be
## saved independently.
project.issues.each do |i|
  if i.changed?
    i.before_serialize project
    fn = File.join project_root, ISSUE_TO_FN(i)
    Ditz::debug "issue #{i.name} is dirty, saving #{fn}"
    i.save! fn
  end
end

project.deleted_issues.each do |i|
  fn = File.join project_root, ISSUE_TO_FN(i)
  Ditz::debug "issue #{i.name} has been deleted, deleting #{fn}"
  FileUtils.rm fn
end

unless project.added_issues.empty?
  puts "You may have to inform your SCM that the following files have been added:"
  project.added_issues.each { |i| puts "  " + File.join(project_root, ISSUE_TO_FN(i)) }
end

unless project.deleted_issues.empty?
  puts "You may have to inform your SCM that the following files have been deleted:"
  project.deleted_issues.each { |i| puts "  " + File.join(project_root, ISSUE_TO_FN(i)) }
end

config.save! $opts[:config_file] if config.changed?

# vim: syntax=ruby
